import type { Topic } from '../types';

export const topics: Topic[] = [
    // SQL Topics
    {
        id: 'sql-intro',
        techId: 'sql',
        title: 'Introduction to SQL & Relational Databases',
        description: 'Overview of SQL and RDBMS concepts.',
        content: '# Introduction to SQL & Relational Databases\n\nSQL is the standard language used to communicate with relational databases. A relational database organizes data into tables made of rows and columns. SQL performs operations like creating tables (DDL), inserting/updating data (DML), retrieving data (SELECT), managing permissions (DCL), and handling transactions (TCL). Relational concepts include primary key, foreign key, normalization, and ACID consistency.',
        levels: ['fresher', 'entry'],
        order: 1,
    },
    {
        id: 'sql-datatypes',
        techId: 'sql',
        title: 'SQL Data Types',
        description: 'Understanding different data types in SQL.',
        content: '# SQL Data Types\n\nSQL supports multiple data types like numbers (INT, NUMBER), strings (VARCHAR, CHAR), dates (DATE, TIMESTAMP), and binary data (BLOB). Choosing proper types improves storage efficiency and performance. Understanding NULL handling is essential because NULL means “unknown,” not zero or empty string.',
        levels: ['fresher', 'entry'],
        order: 2,
    },
    {
        id: 'sql-select',
        techId: 'sql',
        title: 'Basic SELECT & FROM',
        description: 'Retrieving data from tables.',
        content: '# Basic SELECT & FROM\n\nSELECT retrieves data and FROM specifies the source table. You can select specific columns or all columns. Aliases help rename columns for readability. SQL processes SELECT → FROM → WHERE → GROUP BY → HAVING → ORDER BY internally.',
        levels: ['fresher', 'entry'],
        order: 3,
    },
    {
        id: 'sql-where',
        techId: 'sql',
        title: 'WHERE & Filtering',
        description: 'Filtering records based on conditions.',
        content: '# WHERE & Filtering\n\nWHERE filters rows using operators (=, !=, >, <, BETWEEN, LIKE, IN). SQL evaluates WHERE before grouping. Filtering reduces result size and supports complex logical expressions (AND/OR/NOT).',
        levels: ['fresher', 'entry'],
        order: 4,
    },
    {
        id: 'sql-orderby',
        techId: 'sql',
        title: 'ORDER BY & Sorting',
        description: 'Sorting result sets.',
        content: '# ORDER BY\n\nORDER BY sorts results ascending or descending. Sorting affects performance because it may require sorting large datasets in memory or temp storage.',
        levels: ['fresher', 'entry'],
        order: 5,
    },
    {
        id: 'sql-distinct',
        techId: 'sql',
        title: 'DISTINCT',
        description: 'Selecting unique values.',
        content: '# DISTINCT\n\nDISTINCT removes duplicate rows from results. DISTINCT applies to all selected columns, not individual ones. It can be slower on large datasets because sorting or hashing is required.',
        levels: ['fresher', 'entry'],
        order: 6,
    },
    {
        id: 'sql-limit',
        techId: 'sql',
        title: 'Row Limiting',
        description: 'Limiting the number of rows returned.',
        content: '# LIMIT / FETCH / TOP\n\nLimits the number of rows returned. Useful for pagination. Syntax differs by database (LIMIT for MySQL/PostgreSQL, FETCH FIRST for Oracle).',
        levels: ['entry', 'mid'],
        order: 7,
    },
    {
        id: 'sql-aggregates',
        techId: 'sql',
        title: 'Aggregate Functions',
        description: 'COUNT, SUM, AVG, MIN, MAX.',
        content: '# Aggregate Functions\n\nSUM, AVG, COUNT, MIN, MAX summarize data. Aggregations ignore NULL (except COUNT*). Used for reports and analytics.',
        levels: ['entry', 'mid'],
        order: 8,
    },
    {
        id: 'sql-groupby',
        techId: 'sql',
        title: 'GROUP BY',
        description: 'Grouping rows that have the same values.',
        content: '# GROUP BY\n\nGROUP BY groups rows to apply aggregate functions per group. Every column in SELECT must be either grouped or aggregated. Commonly used for department-wise totals, monthly summaries, etc.',
        levels: ['entry', 'mid'],
        order: 9,
    },
    {
        id: 'sql-having',
        techId: 'sql',
        title: 'HAVING',
        description: 'Filtering groups.',
        content: '# HAVING Clause\n\nHAVING filters aggregated groups after GROUP BY. WHERE filters rows before grouping; HAVING filters groups after aggregation.',
        levels: ['entry', 'mid'],
        order: 10,
    },
    {
        id: 'sql-joins',
        techId: 'sql',
        title: 'Joins',
        description: 'Combining rows from two or more tables.',
        content: '# Joins\n\nJoins combine data from two tables using matching columns:\n\n*   **INNER JOIN** → only matched rows\n*   **LEFT JOIN** → all rows from left + matches\n*   **RIGHT JOIN** → opposite of left\n*   **FULL JOIN** → all rows from both tables\n\nJoins are essential in relational data modeling.',
        levels: ['entry', 'mid', 'senior'],
        order: 11,
    },
    {
        id: 'sql-selfjoins',
        techId: 'sql',
        title: 'Self Joins',
        description: 'Joining a table to itself.',
        content: '# Self Joins\n\nA table joins itself using aliases. Useful for hierarchical data like employee-manager relations.',
        levels: ['mid', 'senior'],
        order: 12,
    },
    {
        id: 'sql-subqueries',
        techId: 'sql',
        title: 'Subqueries',
        description: 'Nested queries.',
        content: '# Subqueries\n\nSubqueries are queries inside another query. Types: scalar (single value), multi-row (IN/ANY/ALL), correlated (depends on outer row). Useful for nested calculations.',
        levels: ['mid', 'senior'],
        order: 13,
    },
    {
        id: 'sql-setops',
        techId: 'sql',
        title: 'Set Operations',
        description: 'UNION, INTERSECT, MINUS.',
        content: '# Set Operations\n\nUNION merges results removing duplicates, UNION ALL keeps duplicates. INTERSECT finds common rows. MINUS/EXCEPT finds rows present in first query but not second.',
        levels: ['mid', 'senior'],
        order: 14,
    },
    {
        id: 'sql-functions',
        techId: 'sql',
        title: 'Functions',
        description: 'Built-in SQL functions.',
        content: '# Functions (String/Date/Numeric)\n\nSQL has built-in functions for text (UPPER, SUBSTR), numbers (ROUND, ABS), and dates (ADD_MONTHS, SYSDATE). Functions allow transformation and formatting of data.',
        levels: ['entry', 'mid'],
        order: 15,
    },
    {
        id: 'sql-case',
        techId: 'sql',
        title: 'CASE',
        description: 'Conditional logic in SQL.',
        content: '# CASE Expressions\n\nCASE adds conditional logic inside SELECT. Useful for categorization like grading, statuses, or conditional calculations.',
        levels: ['mid', 'senior'],
        order: 16,
    },
    {
        id: 'sql-dml',
        techId: 'sql',
        title: 'DML',
        description: 'Data Manipulation Language (INSERT, UPDATE, DELETE).',
        content: '# DML – INSERT, UPDATE, DELETE\n\nINSERT adds rows, UPDATE modifies rows, DELETE removes rows. Missing WHERE in UPDATE/DELETE can cause full-table modifications.',
        levels: ['entry', 'mid'],
        order: 17,
    },
    {
        id: 'sql-ddl',
        techId: 'sql',
        title: 'DDL',
        description: 'Data Definition Language (CREATE, ALTER, DROP).',
        content: '# DDL – CREATE, ALTER, DROP\n\nCREATE makes tables, views, indexes. ALTER modifies table structure. DROP removes database objects permanently.',
        levels: ['entry', 'mid'],
        order: 18,
    },
    {
        id: 'sql-constraints',
        techId: 'sql',
        title: 'Constraints',
        description: 'Rules for data in a table.',
        content: '# Constraints\n\nPRIMARY KEY ensures uniqueness, FOREIGN KEY ensures referential integrity, CHECK validates conditions, UNIQUE enforces unique values, NOT NULL prevents empty values.',
        levels: ['entry', 'mid'],
        order: 19,
    },
    {
        id: 'sql-indexes',
        techId: 'sql',
        title: 'Indexes',
        description: 'Improving performance.',
        content: '# Indexes\n\nIndexes improve search speed using B-Trees or other structures. They slow down writes because updates must maintain index structures. Create indexes on frequently searched columns.',
        levels: ['mid', 'senior'],
        order: 20,
    },
    {
        id: 'sql-views',
        techId: 'sql',
        title: 'Views',
        description: 'Virtual tables.',
        content: '# Views\n\nViews are virtual tables based on SQL queries. Good for abstraction, security, and reusable logic. Some views are updatable depending on complexity.',
        levels: ['entry', 'mid'],
        order: 21,
    },
    {
        id: 'sql-transactions',
        techId: 'sql',
        title: 'Transactions',
        description: 'Managing database transactions.',
        content: '# Transactions & Locking\n\nTransaction ensures ACID: Atomicity, Consistency, Isolation, Durability. COMMIT saves changes; ROLLBACK undoes them. Locking prevents inconsistent reads but may cause blocking.',
        levels: ['mid', 'senior'],
        order: 22,
    },
    {
        id: 'sql-window',
        techId: 'sql',
        title: 'Window Functions',
        description: 'Analytics over a set of rows.',
        content: '# Window Functions\n\nWindow functions operate on related rows without collapsing them. Functions: ROW_NUMBER, RANK, LAG, LEAD, running totals, moving averages. Used heavily in analytics.',
        levels: ['senior'],
        order: 23,
    },
    {
        id: 'sql-performance',
        techId: 'sql',
        title: 'Performance',
        description: 'Query optimization and tuning.',
        content: '# Performance Basics\n\nPerformance tuning involves indexes, avoiding unnecessary SELECT *, reducing subqueries, using EXISTS instead of IN sometimes, checking EXPLAIN PLAN, and optimizing joins.',
        levels: ['senior'],
        order: 24,
    },

    // PL/SQL Topics
    {
        id: 'plsql-intro',
        techId: 'plsql',
        title: 'Introduction to PL/SQL & Architecture',
        description: 'Overview of PL/SQL and its architecture.',
        content: '# Introduction to PL/SQL & Architecture\n\nPL/SQL is Oracle’s procedural extension of SQL used for writing complex business logic inside the database. PL/SQL combines SQL with procedural programming elements like conditions, loops, and variables. PL/SQL runs inside the Oracle engine and provides better performance due to reduced network calls. Program units include anonymous blocks, stored procedures, functions, packages, triggers, and object types.',
        levels: ['fresher', 'entry'],
        order: 1,
    },
    {
        id: 'plsql-blocks',
        techId: 'plsql',
        title: 'PL/SQL Block Structure',
        description: 'Structure of PL/SQL blocks.',
        content: '# PL/SQL Block Structure\n\nA PL/SQL block has three optional parts: DECLARE → BEGIN → EXCEPTION → END.\n*   **DECLARE** is used to define variables, constants, cursors, and types.\n*   **BEGIN** section contains executable statements.\n*   **EXCEPTION** handles runtime errors and prevents abrupt termination.',
        levels: ['fresher', 'entry'],
        order: 2,
    },
    {
        id: 'plsql-variables',
        techId: 'plsql',
        title: 'Variables, Constants & Data Types',
        description: 'Declaring and using variables.',
        content: '# Variables, Constants & Data Types\n\n*   **Variables** store data temporarily and must have a datatype.\n*   **Constants** store fixed values using CONSTANT keyword.\n*   **%TYPE** anchors variable datatype to a specific table column.\n*   **%ROWTYPE** anchors a variable to an entire table row structure.',
        levels: ['fresher', 'entry'],
        order: 3,
    },
    {
        id: 'plsql-anchored',
        techId: 'plsql',
        title: 'Anchored Types (%TYPE, %ROWTYPE)',
        description: 'Dynamic data typing.',
        content: '# Anchored Types (%TYPE, %ROWTYPE)\n\nAnchored types allow your code to automatically adopt changes in table structure.\n*   **%TYPE** is used for single column reference.\n*   **%ROWTYPE** stores a complete row with all columns as properties.',
        levels: ['entry', 'mid'],
        order: 4,
    },
    {
        id: 'plsql-operators',
        techId: 'plsql',
        title: 'Operators & Expressions',
        description: 'Arithmetic, relational, and logical operators.',
        content: '# Operators & Expressions\n\nPL/SQL supports arithmetic (+, -, *, /), comparison (=, !=, <), logical (AND, OR, NOT), and string operators. Expressions combine operators, variables, and functions to produce values.',
        levels: ['fresher', 'entry'],
        order: 5,
    },
    {
        id: 'plsql-control',
        techId: 'plsql',
        title: 'Control Structures (IF / CASE)',
        description: 'Conditional control.',
        content: '# Control Structures (IF / CASE)\n\n*   **IF / ELSIF / ELSE** are used for conditional execution.\n*   **CASE** expression is used when multiple conditions need evaluation. CASE improves readability and reduces nested IF conditions.',
        levels: ['entry', 'mid'],
        order: 6,
    },
    {
        id: 'plsql-loops',
        techId: 'plsql',
        title: 'Loops (Basic Loop, While, For)',
        description: 'Iterative control.',
        content: '# Loops (Basic Loop, While, For)\n\nPL/SQL supports LOOP → EXIT WHEN, WHILE LOOP, and FOR LOOP.\n*   **LOOP** executes until EXIT WHEN condition is met.\n*   **FOR LOOP** runs a fixed number of iterations, often used in collections.',
        levels: ['entry', 'mid'],
        order: 7,
    },
    {
        id: 'plsql-cursors',
        techId: 'plsql',
        title: 'Cursors — Implicit & Explicit',
        description: 'Processing multiple rows.',
        content: '# Cursors — Implicit & Explicit\n\n*   **Implicit cursors** automatically handle SELECT INTO statements.\n*   **Explicit cursors** allow multi-row queries and require OPEN, FETCH, CLOSE.\n*   **Cursor FOR LOOP** simplifies fetching because it handles open and close implicitly.',
        levels: ['mid', 'senior'],
        order: 8,
    },
    {
        id: 'plsql-records',
        techId: 'plsql',
        title: 'Records & Composite Data Types',
        description: 'Composite data types.',
        content: '# Records & Composite Data Types\n\nRecords allow grouping multiple fields like table rows.\n*   Types of records: table-based using %ROWTYPE, programmer-defined using TYPE RECORD.\n*   Useful for structured data processing.',
        levels: ['mid', 'senior'],
        order: 9,
    },
    {
        id: 'plsql-collections',
        techId: 'plsql',
        title: 'Collections',
        description: 'VARRAY, Nested Table, Associative Array.',
        content: '# Collections (VARRAY, Nested Table, Associative Array)\n\nCollections store multiple values like arrays.\n*   Types: **VARRAY** (fixed size), **Nested Table** (dynamic), **Associative Array** (key-value).\n*   Collections are widely used for bulk operations and in-memory processing.',
        levels: ['senior'],
        order: 10,
    },
    {
        id: 'plsql-exceptions',
        techId: 'plsql',
        title: 'Exception Handling',
        description: 'Error handling.',
        content: '# Exception Handling\n\nExceptions help handle runtime errors gracefully.\n*   Predefined exceptions: NO_DATA_FOUND, TOO_MANY_ROWS, ZERO_DIVIDE, INVALID_CURSOR.\n*   User-defined exceptions allow custom error management.\n*   RAISE and RAISE_APPLICATION_ERROR generate custom messages.',
        levels: ['mid', 'senior'],
        order: 11,
    },
    {
        id: 'plsql-procedures',
        techId: 'plsql',
        title: 'Stored Procedures',
        description: 'Named PL/SQL blocks.',
        content: '# Stored Procedures\n\nProcedures perform business logic but do not return values directly.\n*   Syntax: `CREATE OR REPLACE PROCEDURE name (params) IS ...`\n*   Useful for reusable modular code and complex operations.',
        levels: ['mid', 'senior'],
        order: 12,
    },
    {
        id: 'plsql-functions',
        techId: 'plsql',
        title: 'Functions',
        description: 'Returning values.',
        content: '# Functions\n\nFunctions return a single value using RETURN keyword.\n*   They can be used in SQL statements if they don’t modify database state.\n*   Useful for calculations, conversions, validations.',
        levels: ['mid', 'senior'],
        order: 13,
    },
    {
        id: 'plsql-packages',
        techId: 'plsql',
        title: 'Packages (Specification & Body)',
        description: 'Grouping related types, items, and subprograms.',
        content: '# Packages (Specification & Body)\n\nA package groups related procedures, functions, cursors, types, variables.\n*   **Specification** contains public elements; **body** contains implementation details.\n*   Packages improve performance through caching and reduce dependencies.',
        levels: ['senior'],
        order: 14,
    },
    {
        id: 'plsql-pkginit',
        techId: 'plsql',
        title: 'Package Initialization',
        description: 'One-time package setup.',
        content: '# Package Initialization\n\nA package runs its initialization block once per session.\n*   Useful for session variables, caching reference data, auditing initialization.',
        levels: ['senior'],
        order: 15,
    },
    {
        id: 'plsql-triggers',
        techId: 'plsql',
        title: 'Triggers',
        description: 'DML, DDL, Database Events.',
        content: '# Triggers (DML, DDL, Database Events)\n\nTriggers are blocks executed automatically on specific events.\n*   Types: BEFORE/AFTER INSERT/UPDATE/DELETE, INSTEAD OF, SYSTEM triggers.\n*   Used for auditing, enforcing business rules, maintaining logs.\n*   Must be used carefully to avoid performance issues.',
        levels: ['mid', 'senior'],
        order: 16,
    },
    {
        id: 'plsql-autonomous',
        techId: 'plsql',
        title: 'Autonomous Transactions',
        description: 'Independent transactions.',
        content: '# Autonomous Transactions\n\nExecuted independently of the main transaction.\n*   Used for logging, auditing, sending emails even if main transaction fails.\n*   Defined using `PRAGMA AUTONOMOUS_TRANSACTION` inside a block.',
        levels: ['senior'],
        order: 17,
    },
    {
        id: 'plsql-dynamic',
        techId: 'plsql',
        title: 'Dynamic SQL (EXECUTE IMMEDIATE)',
        description: 'Generating and executing SQL at runtime.',
        content: '# Dynamic SQL (EXECUTE IMMEDIATE)\n\n`EXECUTE IMMEDIATE` allows building SQL dynamically at runtime.\n*   Used for DDL statements, dynamic WHERE conditions, runtime table selection.\n*   Requires careful handling of SQL injection and performance.',
        levels: ['senior'],
        order: 18,
    },
    {
        id: 'plsql-bulk',
        techId: 'plsql',
        title: 'Bulk Processing (BULK COLLECT, FORALL)',
        description: 'Performance optimization.',
        content: '# Bulk Processing (BULK COLLECT, FORALL)\n\n*   **BULK COLLECT** retrieves multiple rows at once into collections.\n*   **FORALL** performs bulk DML operations efficiently.\n*   Significant performance improvement for ETL and batch processing.',
        levels: ['senior'],
        order: 19,
    },
    {
        id: 'plsql-builtin',
        techId: 'plsql',
        title: 'Oracle Supplied Packages',
        description: 'Standard PL/SQL packages.',
        content: '# Oracle Supplied Packages\n\nUseful packages include: `DBMS_OUTPUT` (debugging), `DBMS_SQL` (dynamic SQL), `DBMS_SCHEDULER` (jobs), `DBMS_UTILITY`, `DBMS_RANDOM`, `DBMS_METADATA`.\nThese enhance PL/SQL capability with system-level operations.',
        levels: ['mid', 'senior'],
        order: 20,
    },
    {
        id: 'plsql-transaction',
        techId: 'plsql',
        title: 'Transaction Control in PL/SQL',
        description: 'Managing transactions.',
        content: '# Transaction Control in PL/SQL\n\n*   `COMMIT`, `ROLLBACK`, `SAVEPOINT` control transactions.\n*   PL/SQL blocks inherit parent transaction state unless autonomous.\n*   Proper transaction design prevents locking problems.',
        levels: ['mid', 'senior'],
        order: 21,
    },
    {
        id: 'plsql-performance',
        techId: 'plsql',
        title: 'PL/SQL Performance Tuning',
        description: 'Optimizing PL/SQL code.',
        content: '# PL/SQL Performance Tuning\n\n*   Use bulk operations for large datasets.\n*   Minimize context switching between SQL & PL/SQL.\n*   Avoid unnecessary loops; use SQL for set-based processing.\n*   Profile code using `DBMS_PROFILER`, `DBMS_HPROF`.',
        levels: ['senior'],
        order: 22,
    },
    {
        id: 'plsql-bestpractices',
        techId: 'plsql',
        title: 'Best Practices',
        description: 'Coding standards and optimization.',
        content: '# Best Practices\n\n*   Use packages for modular design.\n*   Handle exceptions properly.\n*   Use anchored datatypes to avoid datatype mismatches.\n*   Document code using comments.\n*   Follow naming conventions and modular approach.',
        levels: ['mid', 'senior'],
        order: 23,
    },

    // Shell Scripting Topics
    {
        id: 'shell-intro',
        techId: 'shell',
        title: 'Introduction to Shell & Terminal',
        description: 'Basics of Shell and Terminal.',
        content: '# Introduction to Shell & Terminal\n\nThe shell is a command-line interpreter that executes user commands in Linux/Unix systems. Bash is the most widely used shell, providing scripting capabilities and automation. Shell scripts are plain text files that contain commands executed sequentially. Scripts begin with a shebang (`#!/bin/bash`) telling the OS which interpreter to use.',
        levels: ['fresher', 'entry'],
        order: 1,
    },
    {
        id: 'shell-filesystem',
        techId: 'shell',
        title: 'Linux File System Basics',
        description: 'Understanding Linux file system structure.',
        content: '# Linux File System Basics\n\nLinux uses a hierarchical file system starting from root (`/`). Important directories: `/home`, `/etc`, `/var`, `/bin`, `/usr`, `/tmp`. Everything in Linux is treated as a file, including hardware devices.',
        levels: ['fresher', 'entry'],
        order: 2,
    },
    {
        id: 'shell-basic',
        techId: 'shell',
        title: 'Basic Commands & Navigation',
        description: 'Common shell commands.',
        content: '# Basic Commands & Navigation\n\nCommon commands: `ls`, `cd`, `pwd`, `mkdir`, `rmdir`, `cp`, `mv`, `rm`. `ls -l` shows file permissions; `ls -a` shows hidden files. Absolute paths start with `/`. Relative paths depend on current directory.',
        levels: ['fresher', 'entry'],
        order: 3,
    },
    {
        id: 'shell-permissions',
        techId: 'shell',
        title: 'Users, Groups & Permissions',
        description: 'Access control in Linux.',
        content: '# Users, Groups & Permissions\n\nLinux uses user accounts and groups for access control. File permissions: read (r), write (w), execute (x) for user/group/others. Commands: `chmod` (change permissions), `chown` (change owner), `chgrp` (change group).',
        levels: ['entry', 'mid'],
        order: 4,
    },
    {
        id: 'shell-variables',
        techId: 'shell',
        title: 'Variables & Environment',
        description: 'Shell variables and environment variables.',
        content: '# Variables & Environment\n\nVariables store temporary data: `VAR=value`, `echo $VAR`. Environment variables like `PATH`, `HOME`, `USER` affect system behavior. `export VAR` makes variables available to subshells.',
        levels: ['fresher', 'entry'],
        order: 5,
    },
    {
        id: 'shell-quoting',
        techId: 'shell',
        title: 'Quoting & Escaping',
        description: 'Handling special characters.',
        content: '# Quoting & Escaping\n\nSingle quotes (`\'`) preserve literal text, double quotes (`"`) allow variable expansion. Backslash (`\\`) escapes special characters. Correct quoting is essential when working with strings and file names.',
        levels: ['entry', 'mid'],
        order: 6,
    },
    {
        id: 'shell-redirection',
        techId: 'shell',
        title: 'Input/Output & Redirection',
        description: 'Redirecting streams.',
        content: '# Input/Output & Redirection\n\nShell supports redirecting input and output of commands.\n*   `>` overwrites output to file, `>>` appends, `<` takes input from file.\n*   `2>` redirects errors, `&>` redirects both stdout and stderr.',
        levels: ['entry', 'mid'],
        order: 7,
    },
    {
        id: 'shell-pipes',
        techId: 'shell',
        title: 'Pipes & Filters',
        description: 'Chaining commands.',
        content: '# Pipes & Filters\n\nPipes (`|`) pass output of one command as input to another. Common filter utilities: `grep` (pattern search), `cut` (column extraction), `sort`, `uniq`. Pipes allow building powerful multi-step data processing commands.',
        levels: ['entry', 'mid'],
        order: 8,
    },
    {
        id: 'shell-cmdsub',
        techId: 'shell',
        title: 'Command Substitution',
        description: 'Using command output as arguments.',
        content: '# Command Substitution\n\nCommand substitution captures output of commands using `$(command)`. Example: `FILES=$(ls /home)` stores directory listing into a variable. Useful in scripts where dynamic values are required.',
        levels: ['mid', 'senior'],
        order: 9,
    },
    {
        id: 'shell-exitstatus',
        techId: 'shell',
        title: 'Exit Status & Testing',
        description: 'Checking command success/failure.',
        content: '# Exit Status & Testing\n\nEvery command in Linux returns an exit status stored in `$?`. 0 means success, non-zero means failure. `test` and `[ ]` are used for evaluations like file checks, numeric comparisons, string checks.',
        levels: ['mid', 'senior'],
        order: 10,
    },
    {
        id: 'shell-arithmetic',
        techId: 'shell',
        title: 'Arithmetic Operations',
        description: 'Performing math operations.',
        content: '# Arithmetic Operations\n\nShell supports arithmetic using `$(( expression ))`. Operators include +, -, *, /, %, and increment/decrement. Used for counters, loops, and calculations.',
        levels: ['entry', 'mid'],
        order: 11,
    },
    {
        id: 'shell-ifelse',
        techId: 'shell',
        title: 'If/Else Conditions',
        description: 'Conditional execution.',
        content: '# If/Else Conditions\n\n`if`, `elif`, `else` control logical flow. Conditions include numeric comparisons (`-eq`, `-gt`), string comparisons (`=`, `!=`), and file tests. Conditional logic is essential for decision-making scripts.',
        levels: ['entry', 'mid'],
        order: 12,
    },
    {
        id: 'shell-case',
        techId: 'shell',
        title: 'Case Statement',
        description: 'Multi-way branching.',
        content: '# Case Statement\n\nThe `case` statement simplifies multi-condition branching. Often used for menu-driven programs or input validation. It is cleaner and more readable than multiple if-else statements.',
        levels: ['entry', 'mid'],
        order: 13,
    },
    {
        id: 'shell-loops',
        techId: 'shell',
        title: 'Loops — For, While, Until',
        description: 'Iterative control.',
        content: '# Loops — For, While, Until\n\n*   **For loops** iterate over a list or range.\n*   **While loops** run as long as a condition is true.\n*   **Until loops** run until the condition becomes true.\nLoops enable automation of repeated tasks like backups or processing files.',
        levels: ['entry', 'mid'],
        order: 14,
    },
    {
        id: 'shell-functions',
        techId: 'shell',
        title: 'Functions in Shell',
        description: 'Reusable code blocks.',
        content: '# Functions in Shell\n\nFunctions group reusable code blocks. Syntax: `function_name() { commands; }`. Functions allow modular scripting and code reuse.',
        levels: ['mid', 'senior'],
        order: 15,
    },
    {
        id: 'shell-arguments',
        techId: 'shell',
        title: 'Script Arguments & Positional Parameters',
        description: 'Command line arguments.',
        content: '# Script Arguments & Positional Parameters\n\n`$1`, `$2`, `$3` represent command-line arguments. `$#` gives number of arguments; `$@` gives all arguments. Useful for dynamic and interactive scripts.',
        levels: ['entry', 'mid'],
        order: 16,
    },
    {
        id: 'shell-reading',
        techId: 'shell',
        title: 'Reading Input & Files',
        description: 'Processing user input and files.',
        content: '# Reading Input & Files\n\n`read` command accepts user input inside scripts. Shell can read files line-by-line using while loops. `IFS` (Internal Field Separator) controls how text is split.',
        levels: ['mid', 'senior'],
        order: 17,
    },
    {
        id: 'shell-workingfiles',
        techId: 'shell',
        title: 'Working with Files & Directories',
        description: 'File manipulation.',
        content: '# Working with Files & Directories\n\nCommands include `touch`, `rm`, `cp`, `mv`, `mkdir`, `find`. `find` is powerful for searching based on type, size, or name. Shell scripts often automate file management tasks.',
        levels: ['entry', 'mid'],
        order: 18,
    },
    {
        id: 'shell-texttools',
        techId: 'shell',
        title: 'Text Processing Tools (grep, awk, sed)',
        description: 'Advanced text processing.',
        content: '# Text Processing Tools (grep, awk, sed)\n\n*   `grep` filters content based on regex patterns.\n*   `awk` processes structured text and performs operations on columns.\n*   `sed` performs text transformations like substitution, deletion, and insertion.\nCombined, they form the foundation of Unix text processing.',
        levels: ['mid', 'senior'],
        order: 19,
    },
    {
        id: 'shell-cron',
        techId: 'shell',
        title: 'Scheduling Tasks with Cron',
        description: 'Automating tasks.',
        content: '# Scheduling Tasks with Cron\n\n`cron` runs scheduled tasks automatically. `crontab -e` edits the schedule; cron syntax has 5 fields (min hour day month weekday). Used for backups, log cleanup, monitoring, and automation.',
        levels: ['mid', 'senior'],
        order: 20,
    },
    {
        id: 'shell-logging',
        techId: 'shell',
        title: 'Logging & Debugging Scripts',
        description: 'Debugging and logging.',
        content: '# Logging & Debugging Scripts\n\n*   Use `echo` and `printf` for debugging prints.\n*   `set -x` enables execution tracing.\n*   Log files store script output for monitoring and analysis.',
        levels: ['mid', 'senior'],
        order: 21,
    },
    {
        id: 'shell-bestpractices',
        techId: 'shell',
        title: 'Shell Script Best Practices',
        description: 'Writing robust scripts.',
        content: '# Shell Script Best Practices\n\n*   Always use descriptive variable names.\n*   Quote variables properly to avoid bugs.\n*   Use functions to structure logic.\n*   Enable error handling using `set -e` and `trap`.\n*   Write logs for critical processes.',
        levels: ['mid', 'senior'],
        order: 22,
    },
];
